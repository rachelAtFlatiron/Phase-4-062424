# handle creating the api and connecting the database 
# and enabling alembic/migrations

#1. create model Productions
#2. hook up Flask, Flask Migrate/alembic, Flask SQLAlchemy/SQLAlchemy 
#3. migrate our model so that it shows up as a table in our app.db with the following commands:
    # flask db init - create template folders/files to handle migrations and database 
    # flask db revision --autogenerate -m 'message' OR flask db migrate - creates autogenerated alembic script that will populate our app.db 
        # there are some things that the autogenerated scripts cannot detect or will have trouble parsing (mostly happens when you are making a change to a previously created table/model)
        # worst comes to worst you can delete the migrations and instance folder and run flask db init again
    # flask db upgrade head - apply autogenerated script to most recent version
#4. seeded our database (see seed.py)
#5. we made our Flask routes in app.py
    #utilized SQLAlchemy query to access data from our database
    #https://docs.sqlalchemy.org/en/14/orm/query.html#the-query-object
    #SQLAlchemy (our ORM) automatically converts these database rows into Production instances

# SerializerMixin to specify what columns/keyvalue pairs to include in our responses


from flask import Flask, jsonify
from flask_migrate import Migrate 
from models import db, Production

# instance of our api
app = Flask(__name__)
# let our app know what database file to use
app.config["SQLALCHEMY_DATABASE_URI"] = 'sqlite:///app.db'
#uses less memory
app.config["SQLALCHEMY_TRACK_MODIFICATIONS"] = False 

#let migrate know what instance of SQLAlchemy and Flask to use
migrate = Migrate(app, db)
db.init_app(app)



# Note: If you'd like to run the application as a script instead of using `flask run`, uncomment the line below 
# and run `python app.py`


@app.route('/productions')
def all_productions():
    prod_q = Production.query.all()
    prod_list = [prod.to_dict() for prod in prod_q]
    return jsonify(prod_list), 200

#Flask route accesses data via Flask-SQLAlchemy (i.e. the .query stuff)
@app.route('/productions/<string:title>')
def get_movie_by_title(title):
    #q is going to be an instance of Production class/model
    prod_q = Production.query.filter_by(title=title).first()
    #convert q into a dictionary/json so that we can send it as a response 
    #import ipdb; ipdb.set_trace()
    # prod_dict = {
    #     "title": prod_q.title,
    #     "director": prod_q.director,
    #     "year": prod_q.year,
    #     "length": prod_q.length 
    # }
    #convert dictionary into response object
    # Flask will do it automatically if you just return a dictionary, but its still nice to do it manually (for example if you have any custom headers to incldue)
    # prod_json = jsonify(prod_dict)
    #import ipdb; ipdb.set_trace()
    return jsonify(prod_q.to_dict()), 200

@app.route('/productions/<int:year>')
def get_movies_by_year(year):
    #returns a list of Production INSTANCES (not attributes)
    prod_q = Production.query.filter_by(year=year).all()
    # convert each production instance into a dictionary 
    prod_list = []
    for prod in prod_q: 
        prod_dict = {
            "title": prod.title,
            "director": prod.director,
            "year": prod.year,
            "length": prod.length 
        }
        prod_list.append(prod_dict)

    return jsonify(prod_list), 200

@app.route('/longest-movies')
def get_longest_movies():
    prod_q = Production.query.order_by(Production.length.desc()).limit(3)
    # prod_list = []
    # for prod in prod_q: 
    #     prod_dict = {
    #         "title": prod.title,
    #         "length": prod.length 
    #     }
    #     prod_list.append(prod_dict)
    #below rules are specific to this route/prod_list
    prod_list = [prod.to_dict(rules=('-director', '-id', '-year')) for prod in prod_q]
    return jsonify(prod_list), 200
    
# to "connect" this api to your react app (or any other front end) you will do:
# fetch("http://127.0.0.1:5555/productions/Killers%20of%20the%20Flower%20Moon")

if __name__ == '__main__':
    app.run(port=5555, debug=True)